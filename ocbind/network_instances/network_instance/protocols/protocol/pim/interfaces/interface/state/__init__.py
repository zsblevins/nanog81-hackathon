# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/pim/interfaces/interface/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State information for PIM interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__interface_id','__mode','__bsr_border','__border_router','__dr_priority','__join_prune_interval','__hello_interval','__dead_timer','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'pim', 'interfaces', 'interface', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_interface_id(self):
    """
    Getter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    return self.__interface_id
      
  def _set_interface_id(self, v, load=False):
    """
    Setter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_id() directly.

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_id must be of a type compatible with oc-if:interface-id""",
          'defined-type': "oc-if:interface-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)""",
        })

    self.__interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_id(self):
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_bsr_border(self):
    """
    Getter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    return self.__bsr_border
      
  def _set_bsr_border(self, v, load=False):
    """
    Setter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bsr_border is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bsr_border() directly.

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bsr_border must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__bsr_border = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bsr_border(self):
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_border_router(self):
    """
    Getter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    return self.__border_router
      
  def _set_border_router(self, v, load=False):
    """
    Setter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_border_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_border_router() directly.

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """border_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__border_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_border_router(self):
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_dr_priority(self):
    """
    Getter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    return self.__dr_priority
      
  def _set_dr_priority(self, v, load=False):
    """
    Setter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_priority() directly.

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_priority must be of a type compatible with oc-pim-types:dr-priority-type""",
          'defined-type': "oc-pim-types:dr-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)""",
        })

    self.__dr_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_priority(self):
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)


  def _get_join_prune_interval(self):
    """
    Getter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    return self.__join_prune_interval
      
  def _set_join_prune_interval(self, v, load=False):
    """
    Setter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_join_prune_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_join_prune_interval() directly.

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """join_prune_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__join_prune_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_join_prune_interval(self):
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_dead_timer(self):
    """
    Getter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    return self.__dead_timer
      
  def _set_dead_timer(self, v, load=False):
    """
    Setter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_timer() directly.

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__dead_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_timer(self):
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)

    YANG Description: PIM counters for each interface.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: PIM counters for each interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  interface_id = __builtin__.property(_get_interface_id)
  mode = __builtin__.property(_get_mode)
  bsr_border = __builtin__.property(_get_bsr_border)
  border_router = __builtin__.property(_get_border_router)
  dr_priority = __builtin__.property(_get_dr_priority)
  join_prune_interval = __builtin__.property(_get_join_prune_interval)
  hello_interval = __builtin__.property(_get_hello_interval)
  dead_timer = __builtin__.property(_get_dead_timer)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('interface_id', interface_id), ('mode', mode), ('bsr_border', bsr_border), ('border_router', border_router), ('dr_priority', dr_priority), ('join_prune_interval', join_prune_interval), ('hello_interval', hello_interval), ('dead_timer', dead_timer), ('counters', counters), ])


from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/pim/interfaces/interface/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State information for PIM interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__interface_id','__mode','__bsr_border','__border_router','__dr_priority','__join_prune_interval','__hello_interval','__dead_timer','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'pim', 'interfaces', 'interface', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_interface_id(self):
    """
    Getter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    return self.__interface_id
      
  def _set_interface_id(self, v, load=False):
    """
    Setter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_id() directly.

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_id must be of a type compatible with oc-if:interface-id""",
          'defined-type': "oc-if:interface-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)""",
        })

    self.__interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_id(self):
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_bsr_border(self):
    """
    Getter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    return self.__bsr_border
      
  def _set_bsr_border(self, v, load=False):
    """
    Setter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bsr_border is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bsr_border() directly.

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bsr_border must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__bsr_border = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bsr_border(self):
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_border_router(self):
    """
    Getter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    return self.__border_router
      
  def _set_border_router(self, v, load=False):
    """
    Setter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_border_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_border_router() directly.

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """border_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__border_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_border_router(self):
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_dr_priority(self):
    """
    Getter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    return self.__dr_priority
      
  def _set_dr_priority(self, v, load=False):
    """
    Setter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_priority() directly.

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_priority must be of a type compatible with oc-pim-types:dr-priority-type""",
          'defined-type': "oc-pim-types:dr-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)""",
        })

    self.__dr_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_priority(self):
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)


  def _get_join_prune_interval(self):
    """
    Getter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    return self.__join_prune_interval
      
  def _set_join_prune_interval(self, v, load=False):
    """
    Setter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_join_prune_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_join_prune_interval() directly.

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """join_prune_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__join_prune_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_join_prune_interval(self):
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_dead_timer(self):
    """
    Getter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    return self.__dead_timer
      
  def _set_dead_timer(self, v, load=False):
    """
    Setter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_timer() directly.

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__dead_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_timer(self):
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)

    YANG Description: PIM counters for each interface.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: PIM counters for each interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  interface_id = __builtin__.property(_get_interface_id)
  mode = __builtin__.property(_get_mode)
  bsr_border = __builtin__.property(_get_bsr_border)
  border_router = __builtin__.property(_get_border_router)
  dr_priority = __builtin__.property(_get_dr_priority)
  join_prune_interval = __builtin__.property(_get_join_prune_interval)
  hello_interval = __builtin__.property(_get_hello_interval)
  dead_timer = __builtin__.property(_get_dead_timer)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('interface_id', interface_id), ('mode', mode), ('bsr_border', bsr_border), ('border_router', border_router), ('dr_priority', dr_priority), ('join_prune_interval', join_prune_interval), ('hello_interval', hello_interval), ('dead_timer', dead_timer), ('counters', counters), ])


from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/pim/interfaces/interface/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State information for PIM interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__interface_id','__mode','__bsr_border','__border_router','__dr_priority','__join_prune_interval','__hello_interval','__dead_timer','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'pim', 'interfaces', 'interface', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_interface_id(self):
    """
    Getter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    return self.__interface_id
      
  def _set_interface_id(self, v, load=False):
    """
    Setter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_id() directly.

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_id must be of a type compatible with oc-if:interface-id""",
          'defined-type': "oc-if:interface-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)""",
        })

    self.__interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_id(self):
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_bsr_border(self):
    """
    Getter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    return self.__bsr_border
      
  def _set_bsr_border(self, v, load=False):
    """
    Setter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bsr_border is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bsr_border() directly.

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bsr_border must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__bsr_border = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bsr_border(self):
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_border_router(self):
    """
    Getter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    return self.__border_router
      
  def _set_border_router(self, v, load=False):
    """
    Setter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_border_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_border_router() directly.

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """border_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__border_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_border_router(self):
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_dr_priority(self):
    """
    Getter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    return self.__dr_priority
      
  def _set_dr_priority(self, v, load=False):
    """
    Setter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_priority() directly.

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_priority must be of a type compatible with oc-pim-types:dr-priority-type""",
          'defined-type': "oc-pim-types:dr-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)""",
        })

    self.__dr_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_priority(self):
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)


  def _get_join_prune_interval(self):
    """
    Getter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    return self.__join_prune_interval
      
  def _set_join_prune_interval(self, v, load=False):
    """
    Setter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_join_prune_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_join_prune_interval() directly.

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """join_prune_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__join_prune_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_join_prune_interval(self):
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_dead_timer(self):
    """
    Getter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    return self.__dead_timer
      
  def _set_dead_timer(self, v, load=False):
    """
    Setter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_timer() directly.

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__dead_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_timer(self):
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)

    YANG Description: PIM counters for each interface.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: PIM counters for each interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  interface_id = __builtin__.property(_get_interface_id)
  mode = __builtin__.property(_get_mode)
  bsr_border = __builtin__.property(_get_bsr_border)
  border_router = __builtin__.property(_get_border_router)
  dr_priority = __builtin__.property(_get_dr_priority)
  join_prune_interval = __builtin__.property(_get_join_prune_interval)
  hello_interval = __builtin__.property(_get_hello_interval)
  dead_timer = __builtin__.property(_get_dead_timer)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('interface_id', interface_id), ('mode', mode), ('bsr_border', bsr_border), ('border_router', border_router), ('dr_priority', dr_priority), ('join_prune_interval', join_prune_interval), ('hello_interval', hello_interval), ('dead_timer', dead_timer), ('counters', counters), ])


from . import counters
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/pim/interfaces/interface/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State information for PIM interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__interface_id','__mode','__bsr_border','__border_router','__dr_priority','__join_prune_interval','__hello_interval','__dead_timer','__counters',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'pim', 'interfaces', 'interface', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When set to true, the functionality within which this
leaf is defined is enabled, when set to false it is
explicitly disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_interface_id(self):
    """
    Getter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    return self.__interface_id
      
  def _set_interface_id(self, v, load=False):
    """
    Setter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/interface_id (oc-if:interface-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_id() directly.

    YANG Description: Reference to an interface on which PIM is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_id must be of a type compatible with oc-if:interface-id""",
          'defined-type': "oc-if:interface-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)""",
        })

    self.__interface_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_id(self):
    self.__interface_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-if:interface-id', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: PIM mode to use when delivering multicast traffic via this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_SPARSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}, 'oc-pim-types:PIM_MODE_DENSE': {'@module': 'openconfig-pim-types', '@namespace': 'http://openconfig.net/yang/pim/types'}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_bsr_border(self):
    """
    Getter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    return self.__bsr_border
      
  def _set_bsr_border(self, v, load=False):
    """
    Setter method for bsr_border, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/bsr_border (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bsr_border is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bsr_border() directly.

    YANG Description: When set to true the device will not send bootstrap router
messages over this interface. By default these are transmitted
over all PIM sparse mode (PIM-SM) enabled interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bsr_border must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__bsr_border = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bsr_border(self):
    self.__bsr_border = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bsr-border", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_border_router(self):
    """
    Getter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    return self.__border_router
      
  def _set_border_router(self, v, load=False):
    """
    Setter method for border_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/border_router (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_border_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_border_router() directly.

    YANG Description: When set to true the interface is set as MBR (multicast border
router) and allows multicast traffic from sources that are
outside of the PIM domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """border_router must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__border_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_border_router(self):
    self.__border_router = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_dr_priority(self):
    """
    Getter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    return self.__dr_priority
      
  def _set_dr_priority(self, v, load=False):
    """
    Setter method for dr_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dr_priority (oc-pim-types:dr-priority-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_priority() directly.

    YANG Description: The designated router priority of this interface. Larger always
preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_priority must be of a type compatible with oc-pim-types:dr-priority-type""",
          'defined-type': "oc-pim-types:dr-priority-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)""",
        })

    self.__dr_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_priority(self):
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:dr-priority-type', is_config=False)


  def _get_join_prune_interval(self):
    """
    Getter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    return self.__join_prune_interval
      
  def _set_join_prune_interval(self, v, load=False):
    """
    Setter method for join_prune_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/join_prune_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_join_prune_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_join_prune_interval() directly.

    YANG Description: Interval at which the router sends the PIM join/prune messages
toward the upstream RPF neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """join_prune_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__join_prune_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_join_prune_interval(self):
    self.__join_prune_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="join-prune-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/hello_interval (oc-pim-types:pim-interval-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval at which the router sends the PIM hello messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with oc-pim-types:pim-interval-type""",
          'defined-type': "oc-pim-types:pim-interval-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-pim-types:pim-interval-type', is_config=False)


  def _get_dead_timer(self):
    """
    Getter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    return self.__dead_timer
      
  def _set_dead_timer(self, v, load=False):
    """
    Setter method for dead_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/dead_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_timer() directly.

    YANG Description: Number of missed hello messages after which a neighbor is
expired.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__dead_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_timer(self):
    self.__dead_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="dead-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_counters(self):
    """
    Getter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)

    YANG Description: PIM counters for each interface.
    """
    return self.__counters
      
  def _set_counters(self, v, load=False):
    """
    Setter method for counters, mapped from YANG variable /network_instances/network_instance/protocols/protocol/pim/interfaces/interface/state/counters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counters() directly.

    YANG Description: PIM counters for each interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__counters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counters(self):
    self.__counters = YANGDynClass(base=counters.counters, is_container='container', yang_name="counters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  interface_id = __builtin__.property(_get_interface_id)
  mode = __builtin__.property(_get_mode)
  bsr_border = __builtin__.property(_get_bsr_border)
  border_router = __builtin__.property(_get_border_router)
  dr_priority = __builtin__.property(_get_dr_priority)
  join_prune_interval = __builtin__.property(_get_join_prune_interval)
  hello_interval = __builtin__.property(_get_hello_interval)
  dead_timer = __builtin__.property(_get_dead_timer)
  counters = __builtin__.property(_get_counters)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('interface_id', interface_id), ('mode', mode), ('bsr_border', bsr_border), ('border_router', border_router), ('dr_priority', dr_priority), ('join_prune_interval', join_prune_interval), ('hello_interval', hello_interval), ('dead_timer', dead_timer), ('counters', counters), ])


