# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/route-limits/route-limit/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to the route limit.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi','__maximum','__warning_only','__alarm_threshold','__threshold_exceeded','__installed_routes',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'route-limits', 'route-limit', 'state']

  def _get_afi(self):
    """
    Getter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)

    YANG Description: The address family for which the route limit applies.
    """
    return self.__afi
      
  def _set_afi(self, v, load=False):
    """
    Setter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi() directly.

    YANG Description: The address family for which the route limit applies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__afi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi(self):
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_maximum(self):
    """
    Getter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    return self.__maximum
      
  def _set_maximum(self, v, load=False):
    """
    Setter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum() directly.

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__maximum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum(self):
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_warning_only(self):
    """
    Getter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    return self.__warning_only
      
  def _set_warning_only(self, v, load=False):
    """
    Setter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_warning_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_warning_only() directly.

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """warning_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__warning_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_warning_only(self):
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_alarm_threshold(self):
    """
    Getter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    return self.__alarm_threshold
      
  def _set_alarm_threshold(self, v, load=False):
    """
    Setter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_threshold() directly.

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__alarm_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_threshold(self):
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_threshold_exceeded(self):
    """
    Getter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    return self.__threshold_exceeded
      
  def _set_threshold_exceeded(self, v, load=False):
    """
    Setter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_exceeded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_exceeded() directly.

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_exceeded must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__threshold_exceeded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_exceeded(self):
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_installed_routes(self):
    """
    Getter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)

    YANG Description: The current number of routes installed for the address family.
    """
    return self.__installed_routes
      
  def _set_installed_routes(self, v, load=False):
    """
    Setter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_installed_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_installed_routes() directly.

    YANG Description: The current number of routes installed for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """installed_routes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__installed_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_installed_routes(self):
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

  afi = __builtin__.property(_get_afi)
  maximum = __builtin__.property(_get_maximum)
  warning_only = __builtin__.property(_get_warning_only)
  alarm_threshold = __builtin__.property(_get_alarm_threshold)
  threshold_exceeded = __builtin__.property(_get_threshold_exceeded)
  installed_routes = __builtin__.property(_get_installed_routes)


  _pyangbind_elements = OrderedDict([('afi', afi), ('maximum', maximum), ('warning_only', warning_only), ('alarm_threshold', alarm_threshold), ('threshold_exceeded', threshold_exceeded), ('installed_routes', installed_routes), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/route-limits/route-limit/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to the route limit.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi','__maximum','__warning_only','__alarm_threshold','__threshold_exceeded','__installed_routes',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'route-limits', 'route-limit', 'state']

  def _get_afi(self):
    """
    Getter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)

    YANG Description: The address family for which the route limit applies.
    """
    return self.__afi
      
  def _set_afi(self, v, load=False):
    """
    Setter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi() directly.

    YANG Description: The address family for which the route limit applies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__afi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi(self):
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_maximum(self):
    """
    Getter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    return self.__maximum
      
  def _set_maximum(self, v, load=False):
    """
    Setter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum() directly.

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__maximum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum(self):
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_warning_only(self):
    """
    Getter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    return self.__warning_only
      
  def _set_warning_only(self, v, load=False):
    """
    Setter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_warning_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_warning_only() directly.

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """warning_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__warning_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_warning_only(self):
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_alarm_threshold(self):
    """
    Getter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    return self.__alarm_threshold
      
  def _set_alarm_threshold(self, v, load=False):
    """
    Setter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_threshold() directly.

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__alarm_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_threshold(self):
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_threshold_exceeded(self):
    """
    Getter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    return self.__threshold_exceeded
      
  def _set_threshold_exceeded(self, v, load=False):
    """
    Setter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_exceeded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_exceeded() directly.

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_exceeded must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__threshold_exceeded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_exceeded(self):
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_installed_routes(self):
    """
    Getter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)

    YANG Description: The current number of routes installed for the address family.
    """
    return self.__installed_routes
      
  def _set_installed_routes(self, v, load=False):
    """
    Setter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_installed_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_installed_routes() directly.

    YANG Description: The current number of routes installed for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """installed_routes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__installed_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_installed_routes(self):
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

  afi = __builtin__.property(_get_afi)
  maximum = __builtin__.property(_get_maximum)
  warning_only = __builtin__.property(_get_warning_only)
  alarm_threshold = __builtin__.property(_get_alarm_threshold)
  threshold_exceeded = __builtin__.property(_get_threshold_exceeded)
  installed_routes = __builtin__.property(_get_installed_routes)


  _pyangbind_elements = OrderedDict([('afi', afi), ('maximum', maximum), ('warning_only', warning_only), ('alarm_threshold', alarm_threshold), ('threshold_exceeded', threshold_exceeded), ('installed_routes', installed_routes), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/route-limits/route-limit/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to the route limit.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi','__maximum','__warning_only','__alarm_threshold','__threshold_exceeded','__installed_routes',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'route-limits', 'route-limit', 'state']

  def _get_afi(self):
    """
    Getter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)

    YANG Description: The address family for which the route limit applies.
    """
    return self.__afi
      
  def _set_afi(self, v, load=False):
    """
    Setter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi() directly.

    YANG Description: The address family for which the route limit applies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__afi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi(self):
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_maximum(self):
    """
    Getter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    return self.__maximum
      
  def _set_maximum(self, v, load=False):
    """
    Setter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum() directly.

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__maximum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum(self):
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_warning_only(self):
    """
    Getter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    return self.__warning_only
      
  def _set_warning_only(self, v, load=False):
    """
    Setter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_warning_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_warning_only() directly.

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """warning_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__warning_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_warning_only(self):
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_alarm_threshold(self):
    """
    Getter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    return self.__alarm_threshold
      
  def _set_alarm_threshold(self, v, load=False):
    """
    Setter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_threshold() directly.

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__alarm_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_threshold(self):
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_threshold_exceeded(self):
    """
    Getter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    return self.__threshold_exceeded
      
  def _set_threshold_exceeded(self, v, load=False):
    """
    Setter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_exceeded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_exceeded() directly.

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_exceeded must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__threshold_exceeded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_exceeded(self):
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_installed_routes(self):
    """
    Getter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)

    YANG Description: The current number of routes installed for the address family.
    """
    return self.__installed_routes
      
  def _set_installed_routes(self, v, load=False):
    """
    Setter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_installed_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_installed_routes() directly.

    YANG Description: The current number of routes installed for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """installed_routes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__installed_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_installed_routes(self):
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

  afi = __builtin__.property(_get_afi)
  maximum = __builtin__.property(_get_maximum)
  warning_only = __builtin__.property(_get_warning_only)
  alarm_threshold = __builtin__.property(_get_alarm_threshold)
  threshold_exceeded = __builtin__.property(_get_threshold_exceeded)
  installed_routes = __builtin__.property(_get_installed_routes)


  _pyangbind_elements = OrderedDict([('afi', afi), ('maximum', maximum), ('warning_only', warning_only), ('alarm_threshold', alarm_threshold), ('threshold_exceeded', threshold_exceeded), ('installed_routes', installed_routes), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/route-limits/route-limit/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to the route limit.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi','__maximum','__warning_only','__alarm_threshold','__threshold_exceeded','__installed_routes',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'route-limits', 'route-limit', 'state']

  def _get_afi(self):
    """
    Getter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)

    YANG Description: The address family for which the route limit applies.
    """
    return self.__afi
      
  def _set_afi(self, v, load=False):
    """
    Setter method for afi, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/afi (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi() directly.

    YANG Description: The address family for which the route limit applies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)""",
        })

    self.__afi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi(self):
    self.__afi = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV4': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:IPV6': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:MPLS': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'oc-types:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}, 'octypes:L2_ETHERNET': {'@module': 'openconfig-types', '@namespace': 'http://openconfig.net/yang/openconfig-types'}},), is_leaf=True, yang_name="afi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=False)


  def _get_maximum(self):
    """
    Getter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    return self.__maximum
      
  def _set_maximum(self, v, load=False):
    """
    Setter method for maximum, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/maximum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum() directly.

    YANG Description: The maximum number of routes for the address family. The
system should not install more than maximum number of
prefixes into the RIB unless the warning-only leaf is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__maximum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum(self):
    self.__maximum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_warning_only(self):
    """
    Getter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    return self.__warning_only
      
  def _set_warning_only(self, v, load=False):
    """
    Setter method for warning_only, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/warning_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_warning_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_warning_only() directly.

    YANG Description: When specified, the route limit specified is considered only as
a warning - and routes should continue to be installed into the
RIB over the limit specified in the maximum leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """warning_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__warning_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_warning_only(self):
    self.__warning_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="warning-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_alarm_threshold(self):
    """
    Getter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    return self.__alarm_threshold
      
  def _set_alarm_threshold(self, v, load=False):
    """
    Setter method for alarm_threshold, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/alarm_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_threshold() directly.

    YANG Description: When specified, an alarm should be generated when the threshold
number of installed routes is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__alarm_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_threshold(self):
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_threshold_exceeded(self):
    """
    Getter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    return self.__threshold_exceeded
      
  def _set_threshold_exceeded(self, v, load=False):
    """
    Setter method for threshold_exceeded, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/threshold_exceeded (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_exceeded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_exceeded() directly.

    YANG Description: This leaf should be set to true in the case that the threshold
number of routes has been exceeded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_exceeded must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__threshold_exceeded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_exceeded(self):
    self.__threshold_exceeded = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="threshold-exceeded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_installed_routes(self):
    """
    Getter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)

    YANG Description: The current number of routes installed for the address family.
    """
    return self.__installed_routes
      
  def _set_installed_routes(self, v, load=False):
    """
    Setter method for installed_routes, mapped from YANG variable /network_instances/network_instance/route_limits/route_limit/state/installed_routes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_installed_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_installed_routes() directly.

    YANG Description: The current number of routes installed for the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """installed_routes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__installed_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_installed_routes(self):
    self.__installed_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)

  afi = __builtin__.property(_get_afi)
  maximum = __builtin__.property(_get_maximum)
  warning_only = __builtin__.property(_get_warning_only)
  alarm_threshold = __builtin__.property(_get_alarm_threshold)
  threshold_exceeded = __builtin__.property(_get_threshold_exceeded)
  installed_routes = __builtin__.property(_get_installed_routes)


  _pyangbind_elements = OrderedDict([('afi', afi), ('maximum', maximum), ('warning_only', warning_only), ('alarm_threshold', alarm_threshold), ('threshold_exceeded', threshold_exceeded), ('installed_routes', installed_routes), ])


