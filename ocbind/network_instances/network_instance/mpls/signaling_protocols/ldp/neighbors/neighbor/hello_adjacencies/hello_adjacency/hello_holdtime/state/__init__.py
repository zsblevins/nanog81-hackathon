# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State attributes related to the
hello-holdtime.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adjacent','__negotiated','__hello_expiration','__next_hello',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency', 'hello-holdtime', 'state']

  def _get_adjacent(self):
    """
    Getter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    return self.__adjacent
      
  def _set_adjacent(self, v, load=False):
    """
    Setter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjacent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjacent() directly.

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjacent must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__adjacent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjacent(self):
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_negotiated(self):
    """
    Getter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    return self.__negotiated
      
  def _set_negotiated(self, v, load=False):
    """
    Setter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated() directly.

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__negotiated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated(self):
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_hello_expiration(self):
    """
    Getter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)

    YANG Description: Expiration time for the hello holdtime.
    """
    return self.__hello_expiration
      
  def _set_hello_expiration(self, v, load=False):
    """
    Setter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_expiration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_expiration() directly.

    YANG Description: Expiration time for the hello holdtime.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_expiration must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__hello_expiration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_expiration(self):
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)


  def _get_next_hello(self):
    """
    Getter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    return self.__next_hello
      
  def _set_next_hello(self, v, load=False):
    """
    Setter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hello is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hello() directly.

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hello must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__next_hello = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hello(self):
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

  adjacent = __builtin__.property(_get_adjacent)
  negotiated = __builtin__.property(_get_negotiated)
  hello_expiration = __builtin__.property(_get_hello_expiration)
  next_hello = __builtin__.property(_get_next_hello)


  _pyangbind_elements = OrderedDict([('adjacent', adjacent), ('negotiated', negotiated), ('hello_expiration', hello_expiration), ('next_hello', next_hello), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State attributes related to the
hello-holdtime.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adjacent','__negotiated','__hello_expiration','__next_hello',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency', 'hello-holdtime', 'state']

  def _get_adjacent(self):
    """
    Getter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    return self.__adjacent
      
  def _set_adjacent(self, v, load=False):
    """
    Setter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjacent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjacent() directly.

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjacent must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__adjacent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjacent(self):
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_negotiated(self):
    """
    Getter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    return self.__negotiated
      
  def _set_negotiated(self, v, load=False):
    """
    Setter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated() directly.

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__negotiated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated(self):
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_hello_expiration(self):
    """
    Getter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)

    YANG Description: Expiration time for the hello holdtime.
    """
    return self.__hello_expiration
      
  def _set_hello_expiration(self, v, load=False):
    """
    Setter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_expiration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_expiration() directly.

    YANG Description: Expiration time for the hello holdtime.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_expiration must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__hello_expiration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_expiration(self):
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)


  def _get_next_hello(self):
    """
    Getter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    return self.__next_hello
      
  def _set_next_hello(self, v, load=False):
    """
    Setter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hello is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hello() directly.

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hello must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__next_hello = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hello(self):
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

  adjacent = __builtin__.property(_get_adjacent)
  negotiated = __builtin__.property(_get_negotiated)
  hello_expiration = __builtin__.property(_get_hello_expiration)
  next_hello = __builtin__.property(_get_next_hello)


  _pyangbind_elements = OrderedDict([('adjacent', adjacent), ('negotiated', negotiated), ('hello_expiration', hello_expiration), ('next_hello', next_hello), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State attributes related to the
hello-holdtime.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adjacent','__negotiated','__hello_expiration','__next_hello',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency', 'hello-holdtime', 'state']

  def _get_adjacent(self):
    """
    Getter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    return self.__adjacent
      
  def _set_adjacent(self, v, load=False):
    """
    Setter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjacent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjacent() directly.

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjacent must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__adjacent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjacent(self):
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_negotiated(self):
    """
    Getter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    return self.__negotiated
      
  def _set_negotiated(self, v, load=False):
    """
    Setter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated() directly.

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__negotiated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated(self):
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_hello_expiration(self):
    """
    Getter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)

    YANG Description: Expiration time for the hello holdtime.
    """
    return self.__hello_expiration
      
  def _set_hello_expiration(self, v, load=False):
    """
    Setter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_expiration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_expiration() directly.

    YANG Description: Expiration time for the hello holdtime.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_expiration must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__hello_expiration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_expiration(self):
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)


  def _get_next_hello(self):
    """
    Getter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    return self.__next_hello
      
  def _set_next_hello(self, v, load=False):
    """
    Setter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hello is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hello() directly.

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hello must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__next_hello = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hello(self):
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

  adjacent = __builtin__.property(_get_adjacent)
  negotiated = __builtin__.property(_get_negotiated)
  hello_expiration = __builtin__.property(_get_hello_expiration)
  next_hello = __builtin__.property(_get_next_hello)


  _pyangbind_elements = OrderedDict([('adjacent', adjacent), ('negotiated', negotiated), ('hello_expiration', hello_expiration), ('next_hello', next_hello), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State attributes related to the
hello-holdtime.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adjacent','__negotiated','__hello_expiration','__next_hello',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency', 'hello-holdtime', 'state']

  def _get_adjacent(self):
    """
    Getter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    return self.__adjacent
      
  def _set_adjacent(self, v, load=False):
    """
    Setter method for adjacent, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/adjacent (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjacent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjacent() directly.

    YANG Description: Hello holdtime attribute learned from the
LDP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjacent must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__adjacent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjacent(self):
    self.__adjacent = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="adjacent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_negotiated(self):
    """
    Getter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    return self.__negotiated
      
  def _set_negotiated(self, v, load=False):
    """
    Setter method for negotiated, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/negotiated (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated() directly.

    YANG Description: Hello holdtime attribute negotiated between
the LDP neighbor and the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)""",
        })

    self.__negotiated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated(self):
    self.__negotiated = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="negotiated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint16', is_config=False)


  def _get_hello_expiration(self):
    """
    Getter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)

    YANG Description: Expiration time for the hello holdtime.
    """
    return self.__hello_expiration
      
  def _set_hello_expiration(self, v, load=False):
    """
    Setter method for hello_expiration, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/hello_expiration (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_expiration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_expiration() directly.

    YANG Description: Expiration time for the hello holdtime.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_expiration must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__hello_expiration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_expiration(self):
    self.__hello_expiration = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="hello-expiration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)


  def _get_next_hello(self):
    """
    Getter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    return self.__next_hello
      
  def _set_next_hello(self, v, load=False):
    """
    Setter method for next_hello, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime/state/next_hello (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hello is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hello() directly.

    YANG Description: Time when the next LDP hello will be sent to
the adjacent neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hello must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)""",
        })

    self.__next_hello = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hello(self):
    self.__next_hello = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="next-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-types:timeticks64', is_config=False)

  adjacent = __builtin__.property(_get_adjacent)
  negotiated = __builtin__.property(_get_negotiated)
  hello_expiration = __builtin__.property(_get_hello_expiration)
  next_hello = __builtin__.property(_get_next_hello)


  _pyangbind_elements = OrderedDict([('adjacent', adjacent), ('negotiated', negotiated), ('hello_expiration', hello_expiration), ('next_hello', next_hello), ])


