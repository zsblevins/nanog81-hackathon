# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

from . import state
from . import interface_ref
from . import hello_holdtime
class hello_adjacency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of hello adjacencies for a given LDP
neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_address','__local_address','__state','__interface_ref','__hello_holdtime',)

  _yang_name = 'hello-adjacency'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency']

  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)

    YANG Description: Reference to an interface or subinterface
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_hello_holdtime(self):
    """
    Getter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    return self.__hello_holdtime
      
  def _set_hello_holdtime(self, v, load=False):
    """
    Setter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_holdtime() directly.

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_holdtime must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__hello_holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_holdtime(self):
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  remote_address = __builtin__.property(_get_remote_address)
  local_address = __builtin__.property(_get_local_address)
  state = __builtin__.property(_get_state)
  interface_ref = __builtin__.property(_get_interface_ref)
  hello_holdtime = __builtin__.property(_get_hello_holdtime)


  _pyangbind_elements = OrderedDict([('remote_address', remote_address), ('local_address', local_address), ('state', state), ('interface_ref', interface_ref), ('hello_holdtime', hello_holdtime), ])


from . import state
from . import interface_ref
from . import hello_holdtime
class hello_adjacency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of hello adjacencies for a given LDP
neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_address','__local_address','__state','__interface_ref','__hello_holdtime',)

  _yang_name = 'hello-adjacency'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency']

  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)

    YANG Description: Reference to an interface or subinterface
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_hello_holdtime(self):
    """
    Getter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    return self.__hello_holdtime
      
  def _set_hello_holdtime(self, v, load=False):
    """
    Setter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_holdtime() directly.

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_holdtime must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__hello_holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_holdtime(self):
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  remote_address = __builtin__.property(_get_remote_address)
  local_address = __builtin__.property(_get_local_address)
  state = __builtin__.property(_get_state)
  interface_ref = __builtin__.property(_get_interface_ref)
  hello_holdtime = __builtin__.property(_get_hello_holdtime)


  _pyangbind_elements = OrderedDict([('remote_address', remote_address), ('local_address', local_address), ('state', state), ('interface_ref', interface_ref), ('hello_holdtime', hello_holdtime), ])


from . import state
from . import interface_ref
from . import hello_holdtime
class hello_adjacency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of hello adjacencies for a given LDP
neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_address','__local_address','__state','__interface_ref','__hello_holdtime',)

  _yang_name = 'hello-adjacency'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency']

  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)

    YANG Description: Reference to an interface or subinterface
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_hello_holdtime(self):
    """
    Getter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    return self.__hello_holdtime
      
  def _set_hello_holdtime(self, v, load=False):
    """
    Setter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_holdtime() directly.

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_holdtime must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__hello_holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_holdtime(self):
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  remote_address = __builtin__.property(_get_remote_address)
  local_address = __builtin__.property(_get_local_address)
  state = __builtin__.property(_get_state)
  interface_ref = __builtin__.property(_get_interface_ref)
  hello_holdtime = __builtin__.property(_get_hello_holdtime)


  _pyangbind_elements = OrderedDict([('remote_address', remote_address), ('local_address', local_address), ('state', state), ('interface_ref', interface_ref), ('hello_holdtime', hello_holdtime), ])


from . import state
from . import interface_ref
from . import hello_holdtime
class hello_adjacency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of hello adjacencies for a given LDP
neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_address','__local_address','__state','__interface_ref','__hello_holdtime',)

  _yang_name = 'hello-adjacency'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'mpls', 'signaling-protocols', 'ldp', 'neighbors', 'neighbor', 'hello-adjacencies', 'hello-adjacency']

  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/remote_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the neighbor address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/local_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: Within the LDP adjacency, this attribute
shows the local address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State information for a particular LDP
hello adjacency.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_interface_ref(self):
    """
    Getter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)

    YANG Description: Reference to an interface or subinterface
    """
    return self.__interface_ref
      
  def _set_interface_ref(self, v, load=False):
    """
    Setter method for interface_ref, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/interface_ref (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to an interface or subinterface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ref must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__interface_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ref(self):
    self.__interface_ref = YANGDynClass(base=interface_ref.interface_ref, is_container='container', yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_hello_holdtime(self):
    """
    Getter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    return self.__hello_holdtime
      
  def _set_hello_holdtime(self, v, load=False):
    """
    Setter method for hello_holdtime, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/ldp/neighbors/neighbor/hello_adjacencies/hello_adjacency/hello_holdtime (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_holdtime() directly.

    YANG Description: Specifies the time the sending LSR will
maintain its record of Hellos from the
receiving LSR
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_holdtime must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__hello_holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_holdtime(self):
    self.__hello_holdtime = YANGDynClass(base=hello_holdtime.hello_holdtime, is_container='container', yang_name="hello-holdtime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  remote_address = __builtin__.property(_get_remote_address)
  local_address = __builtin__.property(_get_local_address)
  state = __builtin__.property(_get_state)
  interface_ref = __builtin__.property(_get_interface_ref)
  hello_holdtime = __builtin__.property(_get_hello_holdtime)


  _pyangbind_elements = OrderedDict([('remote_address', remote_address), ('local_address', local_address), ('state', state), ('interface_ref', interface_ref), ('hello_holdtime', hello_holdtime), ])


